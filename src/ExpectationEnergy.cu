#include "VMC.h"

	
		/* Returns the potential at a given x,y coordinate
		 * depending on the potential mode of the simulation */

__device__ float Potential(float2 point,
						   int mode)
{
	if (mode == 0)
	{
		return 0.5 * (point.x * point.x + point.y * point.y);
	}
	else if (mode == 1)
	{
		// TODO 
		float alpha = 10;
		float beta = 0.1;
		return alpha*pow(point.x,4.0) - beta*pow(point.x,2.0) +
			  2*pow(beta,2.0)/(4.0*alpha) + alpha*pow(point.y,4.0) - beta * pow(point.y,2.0);
	}
	else if (mode == 2)
	{
		return 0.0;
	}

	// unrecognized mode, shouldn't happen
	return 0.0;
}

		/* Returns the action associated with a particular 
		 * slice of the discrete path. Using the imaginary 
		 * time black magic we add, instead of subtract the 
		 * potential contribution: V */

__device__ float Action(float2* rawRingPoints,
						float2 newPoint,						// the new point on the path generated by the random move
						int mode,
						float dt,
						int numPoints,
					    unsigned int idx)								// the idx of the point that changed
{
	float2 K; // vector components of momentum

	if (idx == 0) // Point is at the beginning of the ring
	{
		K.x = 0.5 * (newPoint.x - rawRingPoints[idx+1].x) * (rawRingPoints[numPoints - 1].x - newPoint.x) / (dt);
		K.y = 0.5 * (newPoint.y - rawRingPoints[idx+1].y) * (rawRingPoints[numPoints - 1].y - newPoint.y) / (dt);
	}
	else if (idx == numPoints - 1) // Point is at the end of the ring
	{
		K.x = 0.5 * (newPoint.x - rawRingPoints[idx+1].x) * (rawRingPoints[0].x - newPoint.x) / (dt);
		K.y = 0.5 * (newPoint.y - rawRingPoints[idx+1].y) * (rawRingPoints[0].y - newPoint.y) / (dt);
	}
	else 
	{
		K.x = 0.5 * (newPoint.x - rawRingPoints[idx-1].x) * (rawRingPoints[idx+1].x - newPoint.x) / (dt);
		K.y = 0.5 * (newPoint.y - rawRingPoints[idx-1].y) * (rawRingPoints[idx+1].y - newPoint.y) / (dt);
	}

	float magK = pow((K.x * K.x + K.y * K.y), 0.5); 
	float V = Potential(newPoint, mode) * dt;
	if (isnan(magK))
	{
		return V;
	}
	return V + magK;
}
		/* Return <E> the expectation (average) energy which the 
		 * electron would have given the distribution defined by 
		 * the path at the current time step. Just sum and divide.
		 * 
		 * Because we've used the imaginary time trick, the sign for 
		 * Potential matches the sign for the Kinetic term in the 
		 * integral and can use the same positive-positive action calc */

__global__ void ExpectationEnergy(float2* rawRingPoints,
								  float* energy,
								  float dt,
								  int mode,
								  int numPoints)
{
	unsigned int idx = blockIdx.x * blockDim.x + threadIdx.x;
	if (idx >= numPoints)
		printf("ERROR: Out of rawRingPoints[] bounds: calling %d, max: %d\n", idx, numPoints);

	float energyAtIdx = Action(rawRingPoints, rawRingPoints[idx], mode, dt, numPoints, idx);

	energy[0] += energyAtIdx;

	__syncthreads();
}